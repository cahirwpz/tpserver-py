
import sys
sys.path.append("../")

import pickle
import copy

import db

import netlib
OK = netlib.objects.OK
Fail = netlib.objects.Fail
Sequence = netlib.objects.Sequence
constants = netlib.objects.constants

class NoSuch(Exception):
	pass

class SQLThing:
	def __init__(self, id=None, packet=None):
		"""\
		SQLObject(id)
		SQLObject(packet)
		SQLObject()

		Create an object from the database using id.
		Create an object from a network packet.
		Create an empty object.
		"""
		if id != None:
			self.load(id)
		if packet != None:
			self.from_packet(packet)

	def todict(self):
		return dict(zip(dir(self),map(lambda s: getattr(self,s),(dir(self)))))

	def attributes(self):
		"""\
		*Internal*

		Get a list of attributes this object type has.
		"""
		if not hasattr(self, "_attributes"):
			self._attributes = db.query("""SELECT * FROM %(tablename)s_type_attr WHERE %(fieldname)s_type_id=%(type)s ORDER BY id""", self.todict())

		return self._attributes

	def load(self, id):
		"""\
		load(id)

		Loads a thing from the database.
		"""
		self.id = id
		
		result = db.query("""SELECT * FROM %(tablename)s WHERE id=%(id)s""", self.todict())
		if len(result) != 1:
			raise NoSuch("%s does not exists" % id)

		self.__dict__.update(result[0])

		# Now for the type specific attributes
		for attribute in self.attributes():
			value = db.query("""SELECT value FROM %(tablename)s_attr WHERE %(fieldname)s_id=%(id)s AND %(fieldname)s_type_attr_id=%(aid)s""", self.todict(), aid=attribute['id'])
			setattr(self, attribute['name'], pickle.loads(value[0]['value']))

	def save(self):
		"""\
		save()

		Saves a thing to the database.
		"""
		# Build SQL query, there must be a better way to do this...
		SQL = """REPLACE INTO %(tablename)s SET """
		for finfo in db.query("DESCRIBE %(tablename)s", tablename=self.tablename):
			if finfo['Field'] == 'id' and not hasattr(self, 'id'):
				continue
			
			SQL += """%(Field)s = "%%(%(Field)s)s", """ % finfo
		SQL = SQL[:-2]

		db.query(SQL, self.todict())

		if not hasattr(self, 'id'):
			self.id = db.connection.insert_id()

		# Now for the type specific attributes
		for attribute in self.attributes():
			value = pickle.dumps(getattr(self, attribute['name']))
			db.query("""REPLACE INTO %(tablename)s_attr VALUES (%(id)s, %(aid)s, "%(value)s")""", self.todict(), aid=attribute['id'], value=value)

	def remove(self):
		"""\
		remove()

		Removes an object from the database.
		"""
		# Remove the common attribute
		db.query("""DELETE FROM %(tablename)s WHERE id=%(id)s""", self.todict())
		db.query("""DELETE FROM %(tablename)s_attr WHERE %(fieldname)s_id=%(id)s""", self.todict())

	def insert(self):
		"""\
		insert()

		Inserts an object into the database.
		"""
		self.save()

	def to_packet(self, sequence):
		"""\
		to_packet(sequence) -> netlib.Packet

		Returns a Thousand Parsec network packet using the sequence number.
		"""
		pass

	def from_packet(self, packet):
		"""\
		from_packet(packet)

		Makes an object out of a Thousand Parsec packet.
		"""
		pass
	
class Object(SQLThing):
	tablename = "tp.object"
	fieldname = "object"

	def orders(self):
		"""\
		orders()

		Returns the number of orders this object has.
		"""
		return Order.number(self.id)

	def ordertypes(self):
		"""\
		ordertypes()

		Returns the valid order types for this object.
		"""
		results = db.query("""SELECT order_type_id FROM object_order_type WHERE object_id=%(id)s""", id=self.id)
		return [x['order_type_id'] for x in results]

	def contains(self):
		"""\
		contains()

		Returns the objects this object contains.
		"""
		results = db.query("""SELECT id FROM object WHERE parent=%(id)s""", id=self.id)
		return [x['id'] for x in results]

	def to_packet(self, sequence):
		# Preset arguments
		args = [sequence, self.id, self.type, self.name, self.size, self.posx, self.posy, self.posz, self.velx, self.vely, self.velz, [], [], self.orders()]
		for attribute in self.attributes():
			value = getattr(self, attribute['name'])
			args.append(value)

		return netlib.objects.Object(*args)

class Order(SQLThing):
	tablename = "tp.order"
	fieldname = "order"
	
	def realid(oid, slot):
		result = db.query("""SELECT id FROM tp.order WHERE oid=%(oid)s and slot=%(slot)s""", oid=oid, slot=slot)
		if len(result) != 1:
			return -1
		else:
			return result[0]['id']
	realid = staticmethod(realid)

	def number(oid):
		return db.query("""SELECT count(oid) FROM tp.order WHERE oid=%(oid)s""", oid=oid)[0]['count(oid)']
	number = staticmethod(number)

	def __init__(self, id=None, slot=None, packet=None):
		if id != None and slot != None:
			self.load(id, slot)
		if packet != None:
			self.from_packet(packet)

	def load(self, oid, slot):
		id = self.realid(oid, slot)
		if id == -1:
			raise NoSuch("Order %s %s does not exists" % (oid, slot))
			
		SQLThing.load(self, id)

	def insert(self):
		number = self.number(self.oid)
		if self.slot == -1:
			self.slot = number
		elif self.slot < number:
			# Need to move all the other orders down
			db.query("""UPDATE tp.order SET slot=slot+1 WHERE slot>=%(slot)s AND oid=%(oid)s""" % self.todict())
		else:
			raise NoSuch("Cannot insert to that slot number.")
		
		self.save()

	def save(self):
		if not hasattr(self, 'id'):
			id = self.realid(self.oid, self.slot)
			if id != -1:
				self.id = id
			
		SQLThing.save(self)

	def remove(self):
		# Move the other orders down
		db.query("""UPDATE tp.order SET slot=slot-1 WHERE slot>=%(slot)s AND oid=%(oid)s""", self.todict())

		SQLThing.remove(self)

	def to_packet(self, sequence):
		# Preset arguments
		args = [sequence, self.oid, self.slot, self.type, 0, []]

		for attribute in self.attributes():
			value = getattr(self, attribute['name'])
			args.append(value)

		return netlib.objects.Order(*args)

	def from_packet(self, packet):
		self.__dict__.update(packet.__dict__)
		self.oid = self.id
		del self.id

class FullConnection(netlib.ServerConnection):
	def OnLogin(self, packet):
		# We need username and password

		args = {'username': packet.username, 'password': packet.password}
		result = db.query("""SELECT * FROM user WHERE username="%(username)s" AND password="%(password)s" """, args)
		if len(result) == 1:
				self._send(OK(packet.sequence, "Login Ok!"))
		else:
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Login incorrect or unknown username!"))
		return True

	def OnObject_GetById(self, packet):
		self._send(Sequence(packet.sequence, len(packet.ids)))

		for id in packet.ids:
			try:
				self._send(Object(id).to_packet(packet.sequence))
			except NoSuch:
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such object."))

		return True

	def OnOrder_Get(self, packet):
		self._send(Sequence(packet.sequence, len(packet.slots)))

		for slot in packet.slots:
			try:
				order = Order(packet.id, slot)
				self._send(order.to_packet(packet.sequence))
			except NoSuch:
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order."))

		return True

	def OnOrder_Insert(self, packet):
		try:
			order = Order(packet=packet)
			order.insert()
			self._send(OK(packet.sequence, "Order added."))
		except NoSuch:
			self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Order adding failed."))

		return True

	OnOrder = OnOrder_Insert

	def OnOrder_Remove(self, packet):
		self._send(Sequence(packet.sequence, len(packet.slots)))

		for slot in packet.slots:
			try:
				order = Order(packet.id, slot)
				order.remove()
				self._send(OK(packet.sequence, "Order removed."))
			except NoSuch:
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order."))

		return True

class FullServer(netlib.Server):
	handler = FullConnection

	def __init__(self, host, port="6923"):
		netlib.Server.__init__(self, host, port)

def main():
	# Connect to the database
	db.connect()

	port = 6923
	while True:
		try:
			s = FullServer("127.0.0.1", port=port)
			print "Used port", port
		except:
			print "This port in use...", port
			port += 1
			continue
		s.serve_forever()

if __name__ == "__main__":
	main()

