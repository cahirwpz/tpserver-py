
import copy
import pickle
import time

import config
from config import db, netlib

OK = netlib.objects.OK
Fail = netlib.objects.Fail
Sequence = netlib.objects.Sequence
constants = netlib.objects.constants

# Base objects
from sbases.SQL     import NoSuch
from sbases.Board   import Board
from sbases.Message import Message
from sbases.Object  import Object
from sbases.Order   import Order
from sbases.User    import User

def allowed(user, obj):
	return (user.id in config.admin) or (hasattr(obj, "owner") and obj.owner == user.id)

class FullConnection(netlib.ServerConnection):
	def __init__(self, *args, **kw):
		netlib.ServerConnection.__init__(self, *args, **kw)
		self.user = None

	def OnLogin(self, packet):
		db.query("USE tp")

		# We need username and password
		pid = User.realid(packet.username, packet.password)
	
		if pid == -1:
			self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Login incorrect or unknown username!"))
		else:
			self.user = User(id=pid)
			self._send(OK(packet.sequence, "Login Ok!"))
			
		return True

	def OnObject_GetById(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.ids)))

		for id in packet.ids:
			try:
				object = Object(id)
				
				p = Object(id).to_packet(packet.sequence)
				
				# Protect the order_number
				if not allowed(self.user, object):
					p.order_number = 0

				self._send(p)
				
			except NoSuch:
				print "No such object", id
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such object."))

		return True
		
	def OnObject_GetByPos(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		objects = Object.bypos(packet.pos, packet.size)

		self._send(Sequence(packet.sequence, len(objects)))

		for object in objects:
			self._send(object.to_packet(packet.sequence))

	def OnOrder_Get(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.slots)))

		for slot in packet.slots:
			try:
				order = Order(packet.id, slot)

				# Are we allowed to access this?
				if not allowed(self.user, order.object):
					self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order."))
					print packet.id, slot, "No Permission"
				else:	
					self._send(order.to_packet(packet.sequence))
			except NoSuch:
				print packet.id, slot, "No such order."
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order."))

		return True

	def OnOrder_Insert(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		try:
			order = Order(packet=packet)
			
			# Are we allowed to do this?
			if not allowed(self.user, order.object):
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Permission denied."))
				print packet.id, slot, "No Permission"
			else:	
				order.insert()
				self._send(OK(packet.sequence, "Order added."))
		except NoSuch:
			print packet.id, slot, "Adding failed."
			self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Order adding failed."))

		return True

	OnOrder = OnOrder_Insert

	def OnOrderDesc_Get(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.ids)))

		for id in packet.ids:
			try:
				self._send(Order.desc_packet(packet.sequence, id))
			except NoSuch:
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order type."))

		return True

	def OnOrder_Remove(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.slots)))

		for slot in packet.slots:
			try:
				order = Order(packet.id, slot)
				
				# Are we allowed to do this?
				if not allowed(self.user, order.object):
					self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order."))
					print self.user.id, packet.id, slot, "No Permission"
				else:	
					order.remove()
					self._send(OK(packet.sequence, "Order removed."))
			except NoSuch:
				print packet.id, slot, "No such order."
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order."))

		return True

	def OnBoard_Get(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.ids)))

		for id in packet.ids:
			try:
				self._send(Board(Board.realid(id, self.user.id)).to_packet(packet.sequence))
			except NoSuch:
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such board."))

		return True
	
	def OnMessage_Get(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.slots)))

		for slot in packet.slots:
			try:
				message = Message(Board.realid(packet.id, self.user.id), slot)
				self._send(message.to_packet(packet.sequence))
			except NoSuch:
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such message."))

		return True

	def OnMessage_Insert(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		try:
			# Mangle the board id
			packet.id = Board.realid(packet.id, self.user.id)

			message = Message(packet=packet)
			message.insert()
			self._send(OK(packet.sequence, "Message added."))
		except NoSuch:
			self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Message adding failed."))

		return True

	OnMessage = OnMessage_Insert

	def OnMessage_Remove(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.slots)))

		for slot in packet.slots:
			try:
				message = Message(Board.realid(packet.id, self.user.id), slot)
				message.remove()
				self._send(OK(packet.sequence, "Message removed."))
			except NoSuch:
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such message."))

		return True

	def _send(self, packet):
		time.sleep(config.lag/1000.0)
		return netlib.ServerConnection._send(self, packet)

class FullServer(netlib.Server):
	handler = FullConnection

	def __init__(self, host, port="6923"):
		netlib.Server.__init__(self, host, port)

	def endofturn(self, sig, frame):
		packet = netlib.objects.TimeRemaining(0, 0)
		for connection in self.connections:
			connection._send(packet)

def main():
	port = 6923
	while True:
		try:
			s = FullServer("", port=port)
			print "Used port", port
		except:
			print "This port in use...", port
			port += 1
			continue
		try:
			import signal

			signal.signal(signal.SIGUSR1, s.endofturn)
		except ImportError:
			pass

		# Import all the order_desc from the database
		Order.load_all()
		for key, value in  netlib.objects.OrderDescs().items():
			print key, value
			print value.names

		s.serve_forever()

if __name__ == "__main__":
	main()

