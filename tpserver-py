#! /usr/bin/env python

import copy
import pickle
import time

import config
from config import db, netlib

OK = netlib.objects.OK
Fail = netlib.objects.Fail
Sequence = netlib.objects.Sequence
constants = netlib.objects.constants

# Base objects
from sbases.SQL       import NoSuch
from sbases.Board     import Board
from sbases.Category  import Category
from sbases.Component import Component
from sbases.Message   import Message
from sbases.Object    import Object
from sbases.Order     import Order
from sbases.User      import User

def allowed(user, obj):
	return (user.id in config.admin) or (hasattr(obj, "owner") and obj.owner == user.id)

class FullConnection(netlib.ServerConnection):
	def __init__(self, *args, **kw):
		netlib.ServerConnection.__init__(self, *args, **kw)
		self.user = None

	def OnGetWithID(self, packet, type):
		"""\
		OnGetWithID(packet, type) -> [True | False]

		packet - Get packet to be processes, it must have the following
			packet.ids	- The ids to be gotten
					
		type - The class used in processing, it must have the following
			type.realid(id, user)		 		 - Get the real id for this object
			type(realid)						 - Creates the object
			typeinstance.allowed(user)			 - Is the user allowed to see this object
			typeinstance.to_packet(sequenceid)	 - Creates a network packet with this sequence number
		"""
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())
		
		self._send(Sequence(packet.sequence, len(packet.ids)))
		for id in packet.ids:
			try:
				# Get the real id
				id = type.realid(id, self.user.id)
				
				o = type(id)

				# Are we allowed to access this?
				if not o.allowed(self.user):
					print "ERROR: No Permission for %s with id %s." % (type, id)
					self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such %s." % type))
				else:	
					self._send(o.to_packet(packet.sequence))

			except NoSuch:
				print "ERROR: No such %s with id %s." % (type, id)
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such %s." % type))

		return True
	
	def OnGetID(self, packet, type):
		"""\
		OnGethID(packet, type) -> [True | False]

		packet - Get packet to be processes, it must have the following
			packet.key	  - The last modified time
			packet.start  - Index to start from
			packet.length - The number of items to get
					
		type - The class used in processing, it must have the following
			type.realid(id, user)		 		 - Get the real id for this object
			type(realid)						 - Creates the object
			typeinstance.allowed(user)			 - Is the user allowed to see this object
			typeinstance.to_packet(sequenceid)	 - Creates a network packet with this sequence number
		"""
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())
		
		key = type.modified()
		total = type.amount()
		
		if packet.start+packet.amount > total:
			self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Requested to many IDs. (Requested %s, Actually %s." % (packet.start+packet.length, total)))
			return True

		if packet.amount == -1:
			left = 0
		else:
			left = total - (packet.start+packet.amount)
			packet.amount = total - packet.start
		
		ids = type.ids(packet.start, packet.amount)
		self._send(type.id_packet()(packet.sequence, key, left, ids))

		return True
	
	def OnGetWithIDandSlot(self, packet, type, container):
		"""\
		OnGetWithIDandSlot(packet, type, container) -> [True | False]

		packet - Get packet to be processes, it must have the following
			packet.id		- The id of the container
			packet.slots	- The slots to be gotten
					
		type - The class used in processing, it must have the following
			type.all(realid)					 - Gets all the ids for this object type
			type(realid, slot)					 - Creates the object
			typeinstance.allowed(user)			 - Is the user allowed to see this object
			typeinstance.to_packet(sequenceid)	 - Creates a network packet with this sequence number

		container - The class that contains the other class
			container.realid(id, user)			 - Get the real id for the container object
		"""
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())
		
		# Get the real id
		id = container.realid(packet.id, self.user.id)
		
		# Empty list means we get all
		if len(packet.slots) == 0:
			packet.slots = type.all(id)
		
		self._send(Sequence(packet.sequence, len(packet.slots)))
		for slot in packet.slots:
			try:
				o = type(id, slot)

				# Are we allowed to access this?
				if not o.allowed(self.user):
					print "ERROR: No Permission for %s with id %s, %s." % (type, id, slot)
					self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order."))
				else:	
					self._send(o.to_packet(packet.sequence))

			except NoSuch:
				print "ERROR: No such %s with id %s, %s." % (type, id, slot)
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order."))

		return True

	def OnLogin(self, packet):
		db.query("USE tp")

		# We need username and password
		pid = User.realid(packet.username, packet.password)
	
		if pid == -1:
			self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Login incorrect or unknown username!"))
		else:
			self.user = User(id=pid)
			self._send(OK(packet.sequence, "Login Ok!"))
			
		return True

	def OnObject_GetById(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.ids)))

		for id in packet.ids:
			try:
				object = Object(id)
				
				p = Object(id).to_packet(packet.sequence)
				
				# Protect the order_number
				if not allowed(self.user, object):
					p.order_number = 0

				self._send(p)
				
			except NoSuch:
				print "No such object", id
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such object."))

		return True
		
	def OnObject_GetID(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		return self.OnGetID(packet, Object)	

	def OnObject_GetID_ByPos(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		objects = Object.bypos(packet.pos, packet.size)

		self._send(Sequence(packet.sequence, len(objects)))

		for object in objects:
			self._send(object.to_packet(packet.sequence))

	def OnOrder_Get(self, packet):
		return self.OnGetWithIDandSlot(packet, Order, Object)

	def OnOrder_Insert(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		try:
			order = Order(packet=packet)
			
			# Are we allowed to do this?
			if not allowed(self.user, order.object):
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Permission denied."))
				print packet.id, packet.slot, "No Permission"
			else:	
				order.insert()
				self._send(OK(packet.sequence, "Order added."))
		except NoSuch:
			print packet.id, packet.slot, "Adding failed."
			self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Order adding failed."))

		return True

	OnOrder = OnOrder_Insert

	def OnOrderDesc_Get(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.ids)))

		for id in packet.ids:
			try:
				self._send(Order.desc_packet(packet.sequence, id))
			except NoSuch:
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order type."))

		return True

	def OnOrder_Remove(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.slots)))

		for slot in packet.slots:
			try:
				order = Order(packet.id, slot)
				
				# Are we allowed to do this?
				if not allowed(self.user, order.object):
					self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order."))
					print self.user.id, packet.id, slot, "No Permission"
				else:	
					order.remove()
					self._send(OK(packet.sequence, "Order removed."))
			except NoSuch:
				print packet.id, slot, "No such order."
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such order."))

		return True

	def OnBoard_Get(self, packet):
		return self.OnGetWithID(packet, Board)
	
	def OnMessage_Get(self, packet):
		return self.OnGetWithIDandSlot(packet, Message, Board)

	def OnMessage_Insert(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		try:
			# Mangle the board id
			packet.id = Board.realid(packet.id, self.user.id)

			message = Message(packet=packet)
			message.insert()
			self._send(OK(packet.sequence, "Message added."))
		except NoSuch:
			self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "Message adding failed."))

		return True

	OnMessage = OnMessage_Insert

	def OnMessage_Remove(self, packet):
		if self.user == None:
			return False
		else:
			db.query("USE %(db)s", db=self.user.domain())

		self._send(Sequence(packet.sequence, len(packet.slots)))

		for slot in packet.slots:
			try:
				message = Message(Board.realid(packet.id, self.user.id), slot)
				message.remove()
				self._send(OK(packet.sequence, "Message removed."))
			except NoSuch:
				self._send(Fail(packet.sequence, constants.FAIL_NOSUCH, "No such message."))

		return True

	def OnCategory_Get(self, packet):
		return self.OnGetWithID(packet, Category)
	
	def OnComponent_Get(self, packet):
		return self.OnGetWithID(packet, Component)
		
	def _send(self, packet):
		time.sleep(config.lag/1000.0)
		return netlib.ServerConnection._send(self, packet)

class FullServer(netlib.Server):
	handler = FullConnection

	def __init__(self, host, port="6923"):
		netlib.Server.__init__(self, host, port)

	def endofturn(self, sig, frame):
		packet = netlib.objects.TimeRemaining(0, 0)
		for connection in self.connections:
			connection._send(packet)

def main():
	port = 6923
	while True:
		try:
			s = FullServer("", port=port)
			print "Used port", port
		except:
			print "This port in use...", port
			port += 1
			continue
		try:
			import signal

			signal.signal(signal.SIGUSR1, s.endofturn)
		except ImportError:
			pass

		# Import all the order_desc from the database
		Order.load_all()
		for key, value in  netlib.objects.OrderDescs().items():
			print key, value
			print value.names

		s.serve_forever()

if __name__ == "__main__":
	main()

